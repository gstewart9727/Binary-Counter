
hello_world_gcc.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000a84  00000000  00000000  00010000  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .stack        00001000  10000000  10000000  00020000  2**2
                  ALLOC
  2 .data         00000004  10001000  00000a84  00011000  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  3 .bss          00000004  10001004  00000a88  00011004  2**2
                  ALLOC
  4 .ARM.attributes 00000037  00000000  00000000  00011004  2**0
                  CONTENTS, READONLY
  5 .debug_info   00004b79  00000000  00000000  0001103b  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_abbrev 00001739  00000000  00000000  00015bb4  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_aranges 00000518  00000000  00000000  000172ed  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_ranges 000007d8  00000000  00000000  00017805  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_line   00002a48  00000000  00000000  00017fdd  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00001dfa  00000000  00000000  0001aa25  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .comment      0000007c  00000000  00000000  0001c81f  2**0
                  CONTENTS, READONLY
 12 .debug_frame  00000b18  00000000  00000000  0001c89c  2**2
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_loc    0000111d  00000000  00000000  0001d3b4  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <g_am_pfnVectors>:
   0:	00 10 00 10 a1 06 00 00 09 07 00 00 49 07 00 00     ............I...
  10:	49 07 00 00 49 07 00 00 49 07 00 00 00 00 00 00     I...I...I.......
	...
  2c:	0f 07 00 00 0f 07 00 00 00 00 00 00 0f 07 00 00     ................
  3c:	0f 07 00 00 0f 07 00 00 0f 07 00 00 0f 07 00 00     ................
  4c:	0f 07 00 00 0f 07 00 00 0f 07 00 00 0f 07 00 00     ................
  5c:	0f 07 00 00 0f 07 00 00 cd 05 00 00 0f 07 00 00     ................
  6c:	0f 07 00 00 0f 07 00 00 0f 07 00 00 0f 07 00 00     ................
  7c:	0f 07 00 00                                         ....

00000080 <main>:
// Main
//
//*****************************************************************************
int
main(void)
{
  80:	b580      	push	{r7, lr}
  82:	b082      	sub	sp, #8
  84:	af00      	add	r7, sp, #0
    // Set the clock frequency.
    am_hal_clkgen_sysclk_select(AM_HAL_CLKGEN_SYSCLK_MAX);
  86:	2000      	movs	r0, #0
  88:	f000 fbf0 	bl	86c <am_hal_clkgen_sysclk_select>

    // Set the default cache configuration
    am_hal_cachectrl_enable(&am_hal_cachectrl_defaults);

    // Configure the board for low power operation.
    am_bsp_low_power_init();
  8c:	f000 fbdc 	bl	848 <am_bsp_low_power_init>

    // Initialize the SWO GPIO pin
    am_bsp_pin_enable(ITM_SWO);
  90:	4ba4      	ldr	r3, [pc, #656]	; (324 <main+0x2a4>)
  92:	2273      	movs	r2, #115	; 0x73
  94:	601a      	str	r2, [r3, #0]
  96:	4aa4      	ldr	r2, [pc, #656]	; (328 <main+0x2a8>)
  98:	4ba3      	ldr	r3, [pc, #652]	; (328 <main+0x2a8>)
  9a:	681b      	ldr	r3, [r3, #0]
  9c:	f023 0370 	bic.w	r3, r3, #112	; 0x70
  a0:	6013      	str	r3, [r2, #0]
  a2:	4aa2      	ldr	r2, [pc, #648]	; (32c <main+0x2ac>)
  a4:	4ba1      	ldr	r3, [pc, #644]	; (32c <main+0x2ac>)
  a6:	681b      	ldr	r3, [r3, #0]
  a8:	f423 437f 	bic.w	r3, r3, #65280	; 0xff00
  ac:	f443 5380 	orr.w	r3, r3, #4096	; 0x1000
  b0:	6013      	str	r3, [r2, #0]
  b2:	4b9c      	ldr	r3, [pc, #624]	; (324 <main+0x2a4>)
  b4:	2200      	movs	r2, #0
  b6:	601a      	str	r2, [r3, #0]

    // Enable the ITM.
    am_hal_itm_enable();
  b8:	f000 fc44 	bl	944 <am_hal_itm_enable>


    // Configure Binary LED Counter GPIO Pins
    am_hal_gpio_pin_config(GPIO_SER_BIN, AM_HAL_PIN_OUTPUT);
  bc:	4b99      	ldr	r3, [pc, #612]	; (324 <main+0x2a4>)
  be:	2273      	movs	r2, #115	; 0x73
  c0:	601a      	str	r2, [r3, #0]
  c2:	4a9b      	ldr	r2, [pc, #620]	; (330 <main+0x2b0>)
  c4:	4b9a      	ldr	r3, [pc, #616]	; (330 <main+0x2b0>)
  c6:	681b      	ldr	r3, [r3, #0]
  c8:	f023 0370 	bic.w	r3, r3, #112	; 0x70
  cc:	f043 0320 	orr.w	r3, r3, #32
  d0:	6013      	str	r3, [r2, #0]
  d2:	4a98      	ldr	r2, [pc, #608]	; (334 <main+0x2b4>)
  d4:	4b97      	ldr	r3, [pc, #604]	; (334 <main+0x2b4>)
  d6:	681b      	ldr	r3, [r3, #0]
  d8:	f423 437f 	bic.w	r3, r3, #65280	; 0xff00
  dc:	f443 53c0 	orr.w	r3, r3, #6144	; 0x1800
  e0:	6013      	str	r3, [r2, #0]
  e2:	4b90      	ldr	r3, [pc, #576]	; (324 <main+0x2a4>)
  e4:	2200      	movs	r2, #0
  e6:	601a      	str	r2, [r3, #0]
    am_hal_gpio_pin_config(GPIO_OE_BIN, AM_HAL_PIN_OUTPUT);
  e8:	4b8e      	ldr	r3, [pc, #568]	; (324 <main+0x2a4>)
  ea:	2273      	movs	r2, #115	; 0x73
  ec:	601a      	str	r2, [r3, #0]
  ee:	4a90      	ldr	r2, [pc, #576]	; (330 <main+0x2b0>)
  f0:	4b8f      	ldr	r3, [pc, #572]	; (330 <main+0x2b0>)
  f2:	681b      	ldr	r3, [r3, #0]
  f4:	f423 63e0 	bic.w	r3, r3, #1792	; 0x700
  f8:	f443 7300 	orr.w	r3, r3, #512	; 0x200
  fc:	6013      	str	r3, [r2, #0]
  fe:	4a8d      	ldr	r2, [pc, #564]	; (334 <main+0x2b4>)
 100:	4b8c      	ldr	r3, [pc, #560]	; (334 <main+0x2b4>)
 102:	681b      	ldr	r3, [r3, #0]
 104:	f423 037f 	bic.w	r3, r3, #16711680	; 0xff0000
 108:	f443 13c0 	orr.w	r3, r3, #1572864	; 0x180000
 10c:	6013      	str	r3, [r2, #0]
 10e:	4b85      	ldr	r3, [pc, #532]	; (324 <main+0x2a4>)
 110:	2200      	movs	r2, #0
 112:	601a      	str	r2, [r3, #0]
    am_hal_gpio_pin_config(GPIO_CLK_BIN, AM_HAL_PIN_OUTPUT);
 114:	4b83      	ldr	r3, [pc, #524]	; (324 <main+0x2a4>)
 116:	2273      	movs	r2, #115	; 0x73
 118:	601a      	str	r2, [r3, #0]
 11a:	4a85      	ldr	r2, [pc, #532]	; (330 <main+0x2b0>)
 11c:	4b84      	ldr	r3, [pc, #528]	; (330 <main+0x2b0>)
 11e:	681b      	ldr	r3, [r3, #0]
 120:	f423 23e0 	bic.w	r3, r3, #458752	; 0x70000
 124:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
 128:	6013      	str	r3, [r2, #0]
 12a:	4a83      	ldr	r2, [pc, #524]	; (338 <main+0x2b8>)
 12c:	4b82      	ldr	r3, [pc, #520]	; (338 <main+0x2b8>)
 12e:	681b      	ldr	r3, [r3, #0]
 130:	f023 03ff 	bic.w	r3, r3, #255	; 0xff
 134:	f043 0318 	orr.w	r3, r3, #24
 138:	6013      	str	r3, [r2, #0]
 13a:	4b7a      	ldr	r3, [pc, #488]	; (324 <main+0x2a4>)
 13c:	2200      	movs	r2, #0
 13e:	601a      	str	r2, [r3, #0]
    am_hal_gpio_pin_config(GPIO_CLR_BIN, AM_HAL_PIN_OUTPUT);
 140:	4b78      	ldr	r3, [pc, #480]	; (324 <main+0x2a4>)
 142:	2273      	movs	r2, #115	; 0x73
 144:	601a      	str	r2, [r3, #0]
 146:	4a7d      	ldr	r2, [pc, #500]	; (33c <main+0x2bc>)
 148:	4b7c      	ldr	r3, [pc, #496]	; (33c <main+0x2bc>)
 14a:	681b      	ldr	r3, [r3, #0]
 14c:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 150:	f043 0320 	orr.w	r3, r3, #32
 154:	6013      	str	r3, [r2, #0]
 156:	4a7a      	ldr	r2, [pc, #488]	; (340 <main+0x2c0>)
 158:	4b79      	ldr	r3, [pc, #484]	; (340 <main+0x2c0>)
 15a:	681b      	ldr	r3, [r3, #0]
 15c:	f423 437f 	bic.w	r3, r3, #65280	; 0xff00
 160:	f443 53c0 	orr.w	r3, r3, #6144	; 0x1800
 164:	6013      	str	r3, [r2, #0]
 166:	4b6f      	ldr	r3, [pc, #444]	; (324 <main+0x2a4>)
 168:	2200      	movs	r2, #0
 16a:	601a      	str	r2, [r3, #0]
	am_hal_gpio_out_bit_clear(GPIO_SER_BIN);
 16c:	4b75      	ldr	r3, [pc, #468]	; (344 <main+0x2c4>)
 16e:	f04f 7200 	mov.w	r2, #33554432	; 0x2000000
 172:	601a      	str	r2, [r3, #0]
	am_hal_gpio_out_bit_clear(GPIO_OE_BIN);
 174:	4b73      	ldr	r3, [pc, #460]	; (344 <main+0x2c4>)
 176:	f04f 6280 	mov.w	r2, #67108864	; 0x4000000
 17a:	601a      	str	r2, [r3, #0]
	am_hal_gpio_out_bit_clear(GPIO_CLK_BIN);
 17c:	4b71      	ldr	r3, [pc, #452]	; (344 <main+0x2c4>)
 17e:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 182:	601a      	str	r2, [r3, #0]
	am_hal_gpio_out_bit_clear(GPIO_CLR_BIN);
 184:	4b70      	ldr	r3, [pc, #448]	; (348 <main+0x2c8>)
 186:	2202      	movs	r2, #2
 188:	601a      	str	r2, [r3, #0]
    am_hal_gpio_out_bit_set(GPIO_OE_BIN);
 18a:	4b70      	ldr	r3, [pc, #448]	; (34c <main+0x2cc>)
 18c:	f04f 6280 	mov.w	r2, #67108864	; 0x4000000
 190:	601a      	str	r2, [r3, #0]
    am_hal_gpio_out_bit_set(GPIO_CLR_BIN);
 192:	4b6f      	ldr	r3, [pc, #444]	; (350 <main+0x2d0>)
 194:	2202      	movs	r2, #2
 196:	601a      	str	r2, [r3, #0]

    // Configure 7-Segment Display GPIO Pins
    am_hal_gpio_pin_config(GPIO_SER_SEG, AM_HAL_PIN_OUTPUT);
 198:	4b62      	ldr	r3, [pc, #392]	; (324 <main+0x2a4>)
 19a:	2273      	movs	r2, #115	; 0x73
 19c:	601a      	str	r2, [r3, #0]
 19e:	4a67      	ldr	r2, [pc, #412]	; (33c <main+0x2bc>)
 1a0:	4b66      	ldr	r3, [pc, #408]	; (33c <main+0x2bc>)
 1a2:	681b      	ldr	r3, [r3, #0]
 1a4:	f023 0307 	bic.w	r3, r3, #7
 1a8:	f043 0302 	orr.w	r3, r3, #2
 1ac:	6013      	str	r3, [r2, #0]
 1ae:	4a64      	ldr	r2, [pc, #400]	; (340 <main+0x2c0>)
 1b0:	4b63      	ldr	r3, [pc, #396]	; (340 <main+0x2c0>)
 1b2:	681b      	ldr	r3, [r3, #0]
 1b4:	f023 03ff 	bic.w	r3, r3, #255	; 0xff
 1b8:	f043 0318 	orr.w	r3, r3, #24
 1bc:	6013      	str	r3, [r2, #0]
 1be:	4b59      	ldr	r3, [pc, #356]	; (324 <main+0x2a4>)
 1c0:	2200      	movs	r2, #0
 1c2:	601a      	str	r2, [r3, #0]
    am_hal_gpio_pin_config(GPIO_OE_SEG, AM_HAL_PIN_OUTPUT);
 1c4:	4b57      	ldr	r3, [pc, #348]	; (324 <main+0x2a4>)
 1c6:	2273      	movs	r2, #115	; 0x73
 1c8:	601a      	str	r2, [r3, #0]
 1ca:	4a59      	ldr	r2, [pc, #356]	; (330 <main+0x2b0>)
 1cc:	4b58      	ldr	r3, [pc, #352]	; (330 <main+0x2b0>)
 1ce:	681b      	ldr	r3, [r3, #0]
 1d0:	f023 43e0 	bic.w	r3, r3, #1879048192	; 0x70000000
 1d4:	f043 5300 	orr.w	r3, r3, #536870912	; 0x20000000
 1d8:	6013      	str	r3, [r2, #0]
 1da:	4a57      	ldr	r2, [pc, #348]	; (338 <main+0x2b8>)
 1dc:	4b56      	ldr	r3, [pc, #344]	; (338 <main+0x2b8>)
 1de:	681b      	ldr	r3, [r3, #0]
 1e0:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
 1e4:	f043 53c0 	orr.w	r3, r3, #402653184	; 0x18000000
 1e8:	6013      	str	r3, [r2, #0]
 1ea:	4b4e      	ldr	r3, [pc, #312]	; (324 <main+0x2a4>)
 1ec:	2200      	movs	r2, #0
 1ee:	601a      	str	r2, [r3, #0]
    am_hal_gpio_pin_config(GPIO_CLK_SEG, AM_HAL_PIN_OUTPUT);
 1f0:	4b4c      	ldr	r3, [pc, #304]	; (324 <main+0x2a4>)
 1f2:	2273      	movs	r2, #115	; 0x73
 1f4:	601a      	str	r2, [r3, #0]
 1f6:	4a4e      	ldr	r2, [pc, #312]	; (330 <main+0x2b0>)
 1f8:	4b4d      	ldr	r3, [pc, #308]	; (330 <main+0x2b0>)
 1fa:	681b      	ldr	r3, [r3, #0]
 1fc:	f023 63e0 	bic.w	r3, r3, #117440512	; 0x7000000
 200:	f043 7300 	orr.w	r3, r3, #33554432	; 0x2000000
 204:	6013      	str	r3, [r2, #0]
 206:	4a4c      	ldr	r2, [pc, #304]	; (338 <main+0x2b8>)
 208:	4b4b      	ldr	r3, [pc, #300]	; (338 <main+0x2b8>)
 20a:	681b      	ldr	r3, [r3, #0]
 20c:	f423 037f 	bic.w	r3, r3, #16711680	; 0xff0000
 210:	f443 13c0 	orr.w	r3, r3, #1572864	; 0x180000
 214:	6013      	str	r3, [r2, #0]
 216:	4b43      	ldr	r3, [pc, #268]	; (324 <main+0x2a4>)
 218:	2200      	movs	r2, #0
 21a:	601a      	str	r2, [r3, #0]
    am_hal_gpio_pin_config(GPIO_CLR_SEG, AM_HAL_PIN_OUTPUT);
 21c:	4b41      	ldr	r3, [pc, #260]	; (324 <main+0x2a4>)
 21e:	2273      	movs	r2, #115	; 0x73
 220:	601a      	str	r2, [r3, #0]
 222:	4a43      	ldr	r2, [pc, #268]	; (330 <main+0x2b0>)
 224:	4b42      	ldr	r3, [pc, #264]	; (330 <main+0x2b0>)
 226:	681b      	ldr	r3, [r3, #0]
 228:	f423 03e0 	bic.w	r3, r3, #7340032	; 0x700000
 22c:	f443 1300 	orr.w	r3, r3, #2097152	; 0x200000
 230:	6013      	str	r3, [r2, #0]
 232:	4a41      	ldr	r2, [pc, #260]	; (338 <main+0x2b8>)
 234:	4b40      	ldr	r3, [pc, #256]	; (338 <main+0x2b8>)
 236:	681b      	ldr	r3, [r3, #0]
 238:	f423 437f 	bic.w	r3, r3, #65280	; 0xff00
 23c:	f443 53c0 	orr.w	r3, r3, #6144	; 0x1800
 240:	6013      	str	r3, [r2, #0]
 242:	4b38      	ldr	r3, [pc, #224]	; (324 <main+0x2a4>)
 244:	2200      	movs	r2, #0
 246:	601a      	str	r2, [r3, #0]
	am_hal_gpio_out_bit_clear(GPIO_SER_SEG);
 248:	4b3f      	ldr	r3, [pc, #252]	; (348 <main+0x2c8>)
 24a:	2201      	movs	r2, #1
 24c:	601a      	str	r2, [r3, #0]
	am_hal_gpio_out_bit_clear(GPIO_OE_SEG);
 24e:	4b3d      	ldr	r3, [pc, #244]	; (344 <main+0x2c4>)
 250:	f04f 4200 	mov.w	r2, #2147483648	; 0x80000000
 254:	601a      	str	r2, [r3, #0]
	am_hal_gpio_out_bit_clear(GPIO_CLK_SEG);
 256:	4b3b      	ldr	r3, [pc, #236]	; (344 <main+0x2c4>)
 258:	f04f 4280 	mov.w	r2, #1073741824	; 0x40000000
 25c:	601a      	str	r2, [r3, #0]
	am_hal_gpio_out_bit_clear(GPIO_CLR_SEG);
 25e:	4b39      	ldr	r3, [pc, #228]	; (344 <main+0x2c4>)
 260:	f04f 5200 	mov.w	r2, #536870912	; 0x20000000
 264:	601a      	str	r2, [r3, #0]
    am_hal_gpio_out_bit_set(GPIO_OE_SEG);
 266:	4b39      	ldr	r3, [pc, #228]	; (34c <main+0x2cc>)
 268:	f04f 4200 	mov.w	r2, #2147483648	; 0x80000000
 26c:	601a      	str	r2, [r3, #0]
    am_hal_gpio_out_bit_set(GPIO_CLR_SEG);
 26e:	4b37      	ldr	r3, [pc, #220]	; (34c <main+0x2cc>)
 270:	f04f 5200 	mov.w	r2, #536870912	; 0x20000000
 274:	601a      	str	r2, [r3, #0]

    // Configure Additional pins used for control
    am_hal_gpio_pin_config(ONES, AM_HAL_PIN_OUTPUT);
 276:	4b2b      	ldr	r3, [pc, #172]	; (324 <main+0x2a4>)
 278:	2273      	movs	r2, #115	; 0x73
 27a:	601a      	str	r2, [r3, #0]
 27c:	4a35      	ldr	r2, [pc, #212]	; (354 <main+0x2d4>)
 27e:	4b35      	ldr	r3, [pc, #212]	; (354 <main+0x2d4>)
 280:	681b      	ldr	r3, [r3, #0]
 282:	f023 0307 	bic.w	r3, r3, #7
 286:	f043 0302 	orr.w	r3, r3, #2
 28a:	6013      	str	r3, [r2, #0]
 28c:	4a32      	ldr	r2, [pc, #200]	; (358 <main+0x2d8>)
 28e:	4b32      	ldr	r3, [pc, #200]	; (358 <main+0x2d8>)
 290:	681b      	ldr	r3, [r3, #0]
 292:	f023 03ff 	bic.w	r3, r3, #255	; 0xff
 296:	f043 0318 	orr.w	r3, r3, #24
 29a:	6013      	str	r3, [r2, #0]
 29c:	4b21      	ldr	r3, [pc, #132]	; (324 <main+0x2a4>)
 29e:	2200      	movs	r2, #0
 2a0:	601a      	str	r2, [r3, #0]
    am_hal_gpio_pin_config(TENS, AM_HAL_PIN_OUTPUT);
 2a2:	4b20      	ldr	r3, [pc, #128]	; (324 <main+0x2a4>)
 2a4:	2273      	movs	r2, #115	; 0x73
 2a6:	601a      	str	r2, [r3, #0]
 2a8:	4a2a      	ldr	r2, [pc, #168]	; (354 <main+0x2d4>)
 2aa:	4b2a      	ldr	r3, [pc, #168]	; (354 <main+0x2d4>)
 2ac:	681b      	ldr	r3, [r3, #0]
 2ae:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 2b2:	f043 0320 	orr.w	r3, r3, #32
 2b6:	6013      	str	r3, [r2, #0]
 2b8:	4a27      	ldr	r2, [pc, #156]	; (358 <main+0x2d8>)
 2ba:	4b27      	ldr	r3, [pc, #156]	; (358 <main+0x2d8>)
 2bc:	681b      	ldr	r3, [r3, #0]
 2be:	f423 437f 	bic.w	r3, r3, #65280	; 0xff00
 2c2:	f443 53c0 	orr.w	r3, r3, #6144	; 0x1800
 2c6:	6013      	str	r3, [r2, #0]
 2c8:	4b16      	ldr	r3, [pc, #88]	; (324 <main+0x2a4>)
 2ca:	2200      	movs	r2, #0
 2cc:	601a      	str	r2, [r3, #0]
    am_hal_gpio_pin_config(HUNDREDS1, AM_HAL_PIN_OUTPUT);
 2ce:	4b15      	ldr	r3, [pc, #84]	; (324 <main+0x2a4>)
 2d0:	2273      	movs	r2, #115	; 0x73
 2d2:	601a      	str	r2, [r3, #0]
 2d4:	4a14      	ldr	r2, [pc, #80]	; (328 <main+0x2a8>)
 2d6:	4b14      	ldr	r3, [pc, #80]	; (328 <main+0x2a8>)
 2d8:	681b      	ldr	r3, [r3, #0]
 2da:	f023 0307 	bic.w	r3, r3, #7
 2de:	f043 0302 	orr.w	r3, r3, #2
 2e2:	6013      	str	r3, [r2, #0]
 2e4:	4a11      	ldr	r2, [pc, #68]	; (32c <main+0x2ac>)
 2e6:	4b11      	ldr	r3, [pc, #68]	; (32c <main+0x2ac>)
 2e8:	681b      	ldr	r3, [r3, #0]
 2ea:	f023 03ff 	bic.w	r3, r3, #255	; 0xff
 2ee:	f043 0318 	orr.w	r3, r3, #24
 2f2:	6013      	str	r3, [r2, #0]
 2f4:	4b0b      	ldr	r3, [pc, #44]	; (324 <main+0x2a4>)
 2f6:	2200      	movs	r2, #0
 2f8:	601a      	str	r2, [r3, #0]
    am_hal_gpio_pin_config(HUNDREDS2, AM_HAL_PIN_OUTPUT);
 2fa:	4b0a      	ldr	r3, [pc, #40]	; (324 <main+0x2a4>)
 2fc:	2273      	movs	r2, #115	; 0x73
 2fe:	601a      	str	r2, [r3, #0]
 300:	4a0e      	ldr	r2, [pc, #56]	; (33c <main+0x2bc>)
 302:	4b0e      	ldr	r3, [pc, #56]	; (33c <main+0x2bc>)
 304:	681b      	ldr	r3, [r3, #0]
 306:	f023 43e0 	bic.w	r3, r3, #1879048192	; 0x70000000
 30a:	f043 5300 	orr.w	r3, r3, #536870912	; 0x20000000
 30e:	6013      	str	r3, [r2, #0]
 310:	4a12      	ldr	r2, [pc, #72]	; (35c <main+0x2dc>)
 312:	4b12      	ldr	r3, [pc, #72]	; (35c <main+0x2dc>)
 314:	681b      	ldr	r3, [r3, #0]
 316:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
 31a:	f043 53c0 	orr.w	r3, r3, #402653184	; 0x18000000
 31e:	6013      	str	r3, [r2, #0]
 320:	e01e      	b.n	360 <main+0x2e0>
 322:	bf00      	nop
 324:	40010060 	.word	0x40010060
 328:	40010054 	.word	0x40010054
 32c:	40010028 	.word	0x40010028
 330:	4001004c 	.word	0x4001004c
 334:	40010018 	.word	0x40010018
 338:	4001001c 	.word	0x4001001c
 33c:	40010050 	.word	0x40010050
 340:	40010020 	.word	0x40010020
 344:	40010098 	.word	0x40010098
 348:	4001009c 	.word	0x4001009c
 34c:	40010090 	.word	0x40010090
 350:	40010094 	.word	0x40010094
 354:	40010044 	.word	0x40010044
 358:	40010008 	.word	0x40010008
 35c:	40010024 	.word	0x40010024
 360:	4b4d      	ldr	r3, [pc, #308]	; (498 <main+0x418>)
 362:	2200      	movs	r2, #0
 364:	601a      	str	r2, [r3, #0]
	am_hal_gpio_out_bit_clear(ONES);
 366:	4b4d      	ldr	r3, [pc, #308]	; (49c <main+0x41c>)
 368:	f44f 7280 	mov.w	r2, #256	; 0x100
 36c:	601a      	str	r2, [r3, #0]
	am_hal_gpio_out_bit_clear(TENS);
 36e:	4b4b      	ldr	r3, [pc, #300]	; (49c <main+0x41c>)
 370:	f44f 7200 	mov.w	r2, #512	; 0x200
 374:	601a      	str	r2, [r3, #0]
	am_hal_gpio_out_bit_clear(HUNDREDS1);
 376:	4b4a      	ldr	r3, [pc, #296]	; (4a0 <main+0x420>)
 378:	f44f 7280 	mov.w	r2, #256	; 0x100
 37c:	601a      	str	r2, [r3, #0]
	am_hal_gpio_out_bit_clear(HUNDREDS2);
 37e:	4b48      	ldr	r3, [pc, #288]	; (4a0 <main+0x420>)
 380:	2280      	movs	r2, #128	; 0x80
 382:	601a      	str	r2, [r3, #0]

    // Configure buttons
    am_hal_gpio_pin_config(AM_BSP_GPIO_BUTTON0, AM_HAL_PIN_INPUT);
 384:	4b44      	ldr	r3, [pc, #272]	; (498 <main+0x418>)
 386:	2273      	movs	r2, #115	; 0x73
 388:	601a      	str	r2, [r3, #0]
 38a:	4a46      	ldr	r2, [pc, #280]	; (4a4 <main+0x424>)
 38c:	4b45      	ldr	r3, [pc, #276]	; (4a4 <main+0x424>)
 38e:	681b      	ldr	r3, [r3, #0]
 390:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 394:	6013      	str	r3, [r2, #0]
 396:	4a44      	ldr	r2, [pc, #272]	; (4a8 <main+0x428>)
 398:	4b43      	ldr	r3, [pc, #268]	; (4a8 <main+0x428>)
 39a:	681b      	ldr	r3, [r3, #0]
 39c:	f423 437f 	bic.w	r3, r3, #65280	; 0xff00
 3a0:	f443 53d0 	orr.w	r3, r3, #6656	; 0x1a00
 3a4:	6013      	str	r3, [r2, #0]
 3a6:	4b3c      	ldr	r3, [pc, #240]	; (498 <main+0x418>)
 3a8:	2200      	movs	r2, #0
 3aa:	601a      	str	r2, [r3, #0]

    // Enable interrupt for button 0
    am_hal_gpio_int_enable(AM_HAL_GPIO_BIT(AM_BSP_GPIO_BUTTON0));
 3ac:	f44f 3000 	mov.w	r0, #131072	; 0x20000
 3b0:	f04f 0100 	mov.w	r1, #0
 3b4:	f000 fa84 	bl	8c0 <am_hal_gpio_int_enable>
    am_hal_interrupt_enable(AM_HAL_INTERRUPT_GPIO);
 3b8:	2019      	movs	r0, #25
 3ba:	f000 fa9b 	bl	8f4 <am_hal_interrupt_enable>

    // Global Variable Declaration
    uint8_t integer = 0;
 3be:	2300      	movs	r3, #0
 3c0:	71fb      	strb	r3, [r7, #7]

	// Clear output
	am_hal_gpio_out_bit_clear(GPIO_CLR_BIN);
 3c2:	4b37      	ldr	r3, [pc, #220]	; (4a0 <main+0x420>)
 3c4:	2202      	movs	r2, #2
 3c6:	601a      	str	r2, [r3, #0]
	am_hal_gpio_out_bit_clear(GPIO_CLK_BIN);
 3c8:	4b34      	ldr	r3, [pc, #208]	; (49c <main+0x41c>)
 3ca:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 3ce:	601a      	str	r2, [r3, #0]
	am_hal_gpio_out_bit_set(GPIO_CLK_BIN);
 3d0:	4b36      	ldr	r3, [pc, #216]	; (4ac <main+0x42c>)
 3d2:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 3d6:	601a      	str	r2, [r3, #0]
	am_hal_gpio_out_bit_set(GPIO_CLR_BIN);
 3d8:	4b35      	ldr	r3, [pc, #212]	; (4b0 <main+0x430>)
 3da:	2202      	movs	r2, #2
 3dc:	601a      	str	r2, [r3, #0]

	am_hal_gpio_out_bit_clear(GPIO_CLR_SEG);
 3de:	4b2f      	ldr	r3, [pc, #188]	; (49c <main+0x41c>)
 3e0:	f04f 5200 	mov.w	r2, #536870912	; 0x20000000
 3e4:	601a      	str	r2, [r3, #0]
	am_hal_gpio_out_bit_clear(GPIO_CLK_SEG);
 3e6:	4b2d      	ldr	r3, [pc, #180]	; (49c <main+0x41c>)
 3e8:	f04f 4280 	mov.w	r2, #1073741824	; 0x40000000
 3ec:	601a      	str	r2, [r3, #0]
	am_hal_gpio_out_bit_set(GPIO_CLK_SEG);
 3ee:	4b2f      	ldr	r3, [pc, #188]	; (4ac <main+0x42c>)
 3f0:	f04f 4280 	mov.w	r2, #1073741824	; 0x40000000
 3f4:	601a      	str	r2, [r3, #0]
	am_hal_gpio_out_bit_set(GPIO_CLR_SEG);
 3f6:	4b2d      	ldr	r3, [pc, #180]	; (4ac <main+0x42c>)
 3f8:	f04f 5200 	mov.w	r2, #536870912	; 0x20000000
 3fc:	601a      	str	r2, [r3, #0]

	// Loop Forever
    while (1)
    {
    	// Load register
    	shiftOut(integer, BINARY_REG);
 3fe:	79fb      	ldrb	r3, [r7, #7]
 400:	2100      	movs	r1, #0
 402:	4618      	mov	r0, r3
 404:	f000 f858 	bl	4b8 <shiftOut>

    	// Turn on binary LEDs
    	am_hal_gpio_out_bit_clear(GPIO_OE_BIN);
 408:	4b24      	ldr	r3, [pc, #144]	; (49c <main+0x41c>)
 40a:	f04f 6280 	mov.w	r2, #67108864	; 0x4000000
 40e:	601a      	str	r2, [r3, #0]

    	// Multiplex display of integer
    	for (int x = 0; x < delay; x++)
 410:	2300      	movs	r3, #0
 412:	603b      	str	r3, [r7, #0]
 414:	e032      	b.n	47c <main+0x3fc>
    	{
    		// Toggle ONES anode
    	    am_hal_gpio_out_bit_set(ONES);
 416:	4b25      	ldr	r3, [pc, #148]	; (4ac <main+0x42c>)
 418:	f44f 7280 	mov.w	r2, #256	; 0x100
 41c:	601a      	str	r2, [r3, #0]
    	    am_hal_gpio_out_bit_clear(TENS);
 41e:	4b1f      	ldr	r3, [pc, #124]	; (49c <main+0x41c>)
 420:	f44f 7200 	mov.w	r2, #512	; 0x200
 424:	601a      	str	r2, [r3, #0]

    	    // Shift out ones value
        	displayInt(integer, 0);
 426:	79fb      	ldrb	r3, [r7, #7]
 428:	2100      	movs	r1, #0
 42a:	4618      	mov	r0, r3
 42c:	f000 f8e0 	bl	5f0 <displayInt>

    		// Toggle display
    		am_hal_gpio_out_bit_clear(GPIO_OE_SEG);
 430:	4b1a      	ldr	r3, [pc, #104]	; (49c <main+0x41c>)
 432:	f04f 4200 	mov.w	r2, #2147483648	; 0x80000000
 436:	601a      	str	r2, [r3, #0]
    		am_util_delay_ms(1);
 438:	2001      	movs	r0, #1
 43a:	f000 f96b 	bl	714 <am_util_delay_ms>
    		am_hal_gpio_out_bit_set(GPIO_OE_SEG);
 43e:	4b1b      	ldr	r3, [pc, #108]	; (4ac <main+0x42c>)
 440:	f04f 4200 	mov.w	r2, #2147483648	; 0x80000000
 444:	601a      	str	r2, [r3, #0]

    		// Toggle TENS anode
    	    am_hal_gpio_out_bit_set(TENS);
 446:	4b19      	ldr	r3, [pc, #100]	; (4ac <main+0x42c>)
 448:	f44f 7200 	mov.w	r2, #512	; 0x200
 44c:	601a      	str	r2, [r3, #0]
    	    am_hal_gpio_out_bit_clear(ONES);
 44e:	4b13      	ldr	r3, [pc, #76]	; (49c <main+0x41c>)
 450:	f44f 7280 	mov.w	r2, #256	; 0x100
 454:	601a      	str	r2, [r3, #0]

    	    // Shift out tens value
        	displayInt(integer, 1);
 456:	79fb      	ldrb	r3, [r7, #7]
 458:	2101      	movs	r1, #1
 45a:	4618      	mov	r0, r3
 45c:	f000 f8c8 	bl	5f0 <displayInt>

    		// Toggle display
    		am_hal_gpio_out_bit_clear(GPIO_OE_SEG);
 460:	4b0e      	ldr	r3, [pc, #56]	; (49c <main+0x41c>)
 462:	f04f 4200 	mov.w	r2, #2147483648	; 0x80000000
 466:	601a      	str	r2, [r3, #0]
    		am_util_delay_ms(1);
 468:	2001      	movs	r0, #1
 46a:	f000 f953 	bl	714 <am_util_delay_ms>
    		am_hal_gpio_out_bit_set(GPIO_OE_SEG);
 46e:	4b0f      	ldr	r3, [pc, #60]	; (4ac <main+0x42c>)
 470:	f04f 4200 	mov.w	r2, #2147483648	; 0x80000000
 474:	601a      	str	r2, [r3, #0]
    	for (int x = 0; x < delay; x++)
 476:	683b      	ldr	r3, [r7, #0]
 478:	3301      	adds	r3, #1
 47a:	603b      	str	r3, [r7, #0]
 47c:	4b0d      	ldr	r3, [pc, #52]	; (4b4 <main+0x434>)
 47e:	681b      	ldr	r3, [r3, #0]
 480:	683a      	ldr	r2, [r7, #0]
 482:	429a      	cmp	r2, r3
 484:	dbc7      	blt.n	416 <main+0x396>
    	}

		// Turn off binary LEDs
		am_hal_gpio_out_bit_set(GPIO_OE_BIN);
 486:	4b09      	ldr	r3, [pc, #36]	; (4ac <main+0x42c>)
 488:	f04f 6280 	mov.w	r2, #67108864	; 0x4000000
 48c:	601a      	str	r2, [r3, #0]

		integer++;
 48e:	79fb      	ldrb	r3, [r7, #7]
 490:	3301      	adds	r3, #1
 492:	71fb      	strb	r3, [r7, #7]
    	shiftOut(integer, BINARY_REG);
 494:	e7b3      	b.n	3fe <main+0x37e>
 496:	bf00      	nop
 498:	40010060 	.word	0x40010060
 49c:	40010098 	.word	0x40010098
 4a0:	4001009c 	.word	0x4001009c
 4a4:	40010048 	.word	0x40010048
 4a8:	40010010 	.word	0x40010010
 4ac:	40010090 	.word	0x40010090
 4b0:	40010094 	.word	0x40010094
 4b4:	10001000 	.word	0x10001000

000004b8 <shiftOut>:
// Description	: This function shifts a value passed to it into the shift register
// Parameters	: uint8_t value - Integer to be passed to register
//				  int reg - Shift register being shifted to
// Returns		: None
void shiftOut(uint8_t value, int reg)
{
 4b8:	b480      	push	{r7}
 4ba:	b087      	sub	sp, #28
 4bc:	af00      	add	r7, sp, #0
 4be:	4603      	mov	r3, r0
 4c0:	6039      	str	r1, [r7, #0]
 4c2:	71fb      	strb	r3, [r7, #7]
	// Variables for register addressing
	int SER, CLK, CLR;

	switch (reg)
 4c4:	683b      	ldr	r3, [r7, #0]
 4c6:	2b00      	cmp	r3, #0
 4c8:	d002      	beq.n	4d0 <shiftOut+0x18>
 4ca:	2b01      	cmp	r3, #1
 4cc:	d007      	beq.n	4de <shiftOut+0x26>
 4ce:	e00d      	b.n	4ec <shiftOut+0x34>
	{
	case BINARY_REG:
		SER = GPIO_SER_BIN;
 4d0:	2319      	movs	r3, #25
 4d2:	617b      	str	r3, [r7, #20]
		CLK = GPIO_CLK_BIN;
 4d4:	231c      	movs	r3, #28
 4d6:	613b      	str	r3, [r7, #16]
		CLR = GPIO_CLR_BIN;
 4d8:	2321      	movs	r3, #33	; 0x21
 4da:	60fb      	str	r3, [r7, #12]
		break;
 4dc:	e006      	b.n	4ec <shiftOut+0x34>
	case SEGMENT_REG:
		SER = GPIO_SER_SEG;
 4de:	2320      	movs	r3, #32
 4e0:	617b      	str	r3, [r7, #20]
		CLK = GPIO_CLK_SEG;
 4e2:	231e      	movs	r3, #30
 4e4:	613b      	str	r3, [r7, #16]
		CLR = GPIO_CLR_SEG;
 4e6:	231d      	movs	r3, #29
 4e8:	60fb      	str	r3, [r7, #12]
		break;
 4ea:	bf00      	nop
	}

	// Clear Register
	am_hal_gpio_out_bit_clear(CLR);
 4ec:	68fb      	ldr	r3, [r7, #12]
 4ee:	08db      	lsrs	r3, r3, #3
 4f0:	f003 0204 	and.w	r2, r3, #4
 4f4:	4b33      	ldr	r3, [pc, #204]	; (5c4 <shiftOut+0x10c>)
 4f6:	4413      	add	r3, r2
 4f8:	4619      	mov	r1, r3
 4fa:	68fb      	ldr	r3, [r7, #12]
 4fc:	f003 031f 	and.w	r3, r3, #31
 500:	2201      	movs	r2, #1
 502:	fa02 f303 	lsl.w	r3, r2, r3
 506:	600b      	str	r3, [r1, #0]
	am_hal_gpio_out_bit_set(CLR);
 508:	68fb      	ldr	r3, [r7, #12]
 50a:	08db      	lsrs	r3, r3, #3
 50c:	f003 0204 	and.w	r2, r3, #4
 510:	4b2d      	ldr	r3, [pc, #180]	; (5c8 <shiftOut+0x110>)
 512:	4413      	add	r3, r2
 514:	4619      	mov	r1, r3
 516:	68fb      	ldr	r3, [r7, #12]
 518:	f003 031f 	and.w	r3, r3, #31
 51c:	2201      	movs	r2, #1
 51e:	fa02 f303 	lsl.w	r3, r2, r3
 522:	600b      	str	r3, [r1, #0]

	// Shift out to register
	for (int x = 0; x <= 8; x++)
 524:	2300      	movs	r3, #0
 526:	60bb      	str	r3, [r7, #8]
 528:	e043      	b.n	5b2 <shiftOut+0xfa>
	{
    	// Set SER low or high based on current binary value
		if (value & (1<<x)) {
 52a:	79fa      	ldrb	r2, [r7, #7]
 52c:	68bb      	ldr	r3, [r7, #8]
 52e:	fa42 f303 	asr.w	r3, r2, r3
 532:	f003 0301 	and.w	r3, r3, #1
 536:	2b00      	cmp	r3, #0
 538:	d00e      	beq.n	558 <shiftOut+0xa0>
			am_hal_gpio_out_bit_set(SER);
 53a:	697b      	ldr	r3, [r7, #20]
 53c:	08db      	lsrs	r3, r3, #3
 53e:	f003 0204 	and.w	r2, r3, #4
 542:	4b21      	ldr	r3, [pc, #132]	; (5c8 <shiftOut+0x110>)
 544:	4413      	add	r3, r2
 546:	4619      	mov	r1, r3
 548:	697b      	ldr	r3, [r7, #20]
 54a:	f003 031f 	and.w	r3, r3, #31
 54e:	2201      	movs	r2, #1
 550:	fa02 f303 	lsl.w	r3, r2, r3
 554:	600b      	str	r3, [r1, #0]
 556:	e00d      	b.n	574 <shiftOut+0xbc>
		}
		else
			am_hal_gpio_out_bit_clear(SER);
 558:	697b      	ldr	r3, [r7, #20]
 55a:	08db      	lsrs	r3, r3, #3
 55c:	f003 0204 	and.w	r2, r3, #4
 560:	4b18      	ldr	r3, [pc, #96]	; (5c4 <shiftOut+0x10c>)
 562:	4413      	add	r3, r2
 564:	4619      	mov	r1, r3
 566:	697b      	ldr	r3, [r7, #20]
 568:	f003 031f 	and.w	r3, r3, #31
 56c:	2201      	movs	r2, #1
 56e:	fa02 f303 	lsl.w	r3, r2, r3
 572:	600b      	str	r3, [r1, #0]


    	// Cycle clock
    	am_hal_gpio_out_bit_set(CLK);
 574:	693b      	ldr	r3, [r7, #16]
 576:	08db      	lsrs	r3, r3, #3
 578:	f003 0204 	and.w	r2, r3, #4
 57c:	4b12      	ldr	r3, [pc, #72]	; (5c8 <shiftOut+0x110>)
 57e:	4413      	add	r3, r2
 580:	4619      	mov	r1, r3
 582:	693b      	ldr	r3, [r7, #16]
 584:	f003 031f 	and.w	r3, r3, #31
 588:	2201      	movs	r2, #1
 58a:	fa02 f303 	lsl.w	r3, r2, r3
 58e:	600b      	str	r3, [r1, #0]
    	am_hal_gpio_out_bit_clear(CLK);
 590:	693b      	ldr	r3, [r7, #16]
 592:	08db      	lsrs	r3, r3, #3
 594:	f003 0204 	and.w	r2, r3, #4
 598:	4b0a      	ldr	r3, [pc, #40]	; (5c4 <shiftOut+0x10c>)
 59a:	4413      	add	r3, r2
 59c:	4619      	mov	r1, r3
 59e:	693b      	ldr	r3, [r7, #16]
 5a0:	f003 031f 	and.w	r3, r3, #31
 5a4:	2201      	movs	r2, #1
 5a6:	fa02 f303 	lsl.w	r3, r2, r3
 5aa:	600b      	str	r3, [r1, #0]
	for (int x = 0; x <= 8; x++)
 5ac:	68bb      	ldr	r3, [r7, #8]
 5ae:	3301      	adds	r3, #1
 5b0:	60bb      	str	r3, [r7, #8]
 5b2:	68bb      	ldr	r3, [r7, #8]
 5b4:	2b08      	cmp	r3, #8
 5b6:	ddb8      	ble.n	52a <shiftOut+0x72>
	}
}
 5b8:	bf00      	nop
 5ba:	371c      	adds	r7, #28
 5bc:	46bd      	mov	sp, r7
 5be:	f85d 7b04 	ldr.w	r7, [sp], #4
 5c2:	4770      	bx	lr
 5c4:	40010098 	.word	0x40010098
 5c8:	40010090 	.word	0x40010090

000005cc <am_gpio_isr>:
// Function		: am_gpio_isr
// Description	: This handler is called when the button is pushed
// Parameters	: void
// Returns		: None
void am_gpio_isr(void)
{
 5cc:	b580      	push	{r7, lr}
 5ce:	af00      	add	r7, sp, #0
    //
    // Clear the GPIO Interrupt (write to clear).
    //
    am_hal_gpio_int_clear(AM_HAL_GPIO_BIT(AM_BSP_GPIO_BUTTON0));
 5d0:	f44f 3000 	mov.w	r0, #131072	; 0x20000
 5d4:	f04f 0100 	mov.w	r1, #0
 5d8:	f000 f982 	bl	8e0 <am_hal_gpio_int_clear>
    // Perform interrupt functionality here
    delay += 100;
 5dc:	4b03      	ldr	r3, [pc, #12]	; (5ec <am_gpio_isr+0x20>)
 5de:	681b      	ldr	r3, [r3, #0]
 5e0:	3364      	adds	r3, #100	; 0x64
 5e2:	4a02      	ldr	r2, [pc, #8]	; (5ec <am_gpio_isr+0x20>)
 5e4:	6013      	str	r3, [r2, #0]
}
 5e6:	bf00      	nop
 5e8:	bd80      	pop	{r7, pc}
 5ea:	bf00      	nop
 5ec:	10001000 	.word	0x10001000

000005f0 <displayInt>:
// Parameters	: int number - Value to represent on display
//				  int place - Display we are using
// Returns		: None
// Notes		:
void displayInt(int number, int place)
{
 5f0:	b580      	push	{r7, lr}
 5f2:	b086      	sub	sp, #24
 5f4:	af00      	add	r7, sp, #0
 5f6:	6078      	str	r0, [r7, #4]
 5f8:	6039      	str	r1, [r7, #0]
	// Variable declaration
	int multiple = 0;
 5fa:	2300      	movs	r3, #0
 5fc:	617b      	str	r3, [r7, #20]

	uint8_t array[10] = { 0x77, 0x11, 0x6B, 0x3B, 0x1D, 0x3E, 0x7E, 0x13, 0x7F, 0x3F };
 5fe:	4a24      	ldr	r2, [pc, #144]	; (690 <displayInt+0xa0>)
 600:	f107 0308 	add.w	r3, r7, #8
 604:	ca07      	ldmia	r2, {r0, r1, r2}
 606:	c303      	stmia	r3!, {r0, r1}
 608:	801a      	strh	r2, [r3, #0]

	// Clear hundreds LEDs
	am_hal_gpio_out_bit_clear(HUNDREDS1);
 60a:	4b22      	ldr	r3, [pc, #136]	; (694 <displayInt+0xa4>)
 60c:	f44f 7280 	mov.w	r2, #256	; 0x100
 610:	601a      	str	r2, [r3, #0]
	am_hal_gpio_out_bit_clear(HUNDREDS2);
 612:	4b20      	ldr	r3, [pc, #128]	; (694 <displayInt+0xa4>)
 614:	2280      	movs	r2, #128	; 0x80
 616:	601a      	str	r2, [r3, #0]

	// If we are above one/two hundred, remove one hundred
	if (number >= 200) {
 618:	687b      	ldr	r3, [r7, #4]
 61a:	2bc7      	cmp	r3, #199	; 0xc7
 61c:	dd06      	ble.n	62c <displayInt+0x3c>
		number -= 100;
 61e:	687b      	ldr	r3, [r7, #4]
 620:	3b64      	subs	r3, #100	; 0x64
 622:	607b      	str	r3, [r7, #4]
		am_hal_gpio_out_bit_set(HUNDREDS1);
 624:	4b1c      	ldr	r3, [pc, #112]	; (698 <displayInt+0xa8>)
 626:	f44f 7280 	mov.w	r2, #256	; 0x100
 62a:	601a      	str	r2, [r3, #0]
	}

	if (number >= 100) {
 62c:	687b      	ldr	r3, [r7, #4]
 62e:	2b63      	cmp	r3, #99	; 0x63
 630:	dd05      	ble.n	63e <displayInt+0x4e>
		number -= 100;
 632:	687b      	ldr	r3, [r7, #4]
 634:	3b64      	subs	r3, #100	; 0x64
 636:	607b      	str	r3, [r7, #4]
		am_hal_gpio_out_bit_set(HUNDREDS2);
 638:	4b17      	ldr	r3, [pc, #92]	; (698 <displayInt+0xa8>)
 63a:	2280      	movs	r2, #128	; 0x80
 63c:	601a      	str	r2, [r3, #0]
	}

	// Determine if we are displaying ones or tens place
	if (place == 0)
 63e:	683b      	ldr	r3, [r7, #0]
 640:	2b00      	cmp	r3, #0
 642:	d10d      	bne.n	660 <displayInt+0x70>
		multiple = number % 10;
 644:	687a      	ldr	r2, [r7, #4]
 646:	4b15      	ldr	r3, [pc, #84]	; (69c <displayInt+0xac>)
 648:	fb83 1302 	smull	r1, r3, r3, r2
 64c:	1099      	asrs	r1, r3, #2
 64e:	17d3      	asrs	r3, r2, #31
 650:	1ac9      	subs	r1, r1, r3
 652:	460b      	mov	r3, r1
 654:	009b      	lsls	r3, r3, #2
 656:	440b      	add	r3, r1
 658:	005b      	lsls	r3, r3, #1
 65a:	1ad3      	subs	r3, r2, r3
 65c:	617b      	str	r3, [r7, #20]
 65e:	e007      	b.n	670 <displayInt+0x80>
	else
		multiple = number / 10;
 660:	687b      	ldr	r3, [r7, #4]
 662:	4a0e      	ldr	r2, [pc, #56]	; (69c <displayInt+0xac>)
 664:	fb82 1203 	smull	r1, r2, r2, r3
 668:	1092      	asrs	r2, r2, #2
 66a:	17db      	asrs	r3, r3, #31
 66c:	1ad3      	subs	r3, r2, r3
 66e:	617b      	str	r3, [r7, #20]

	// Depending on number to display, clear particular bits
	shiftOut(~array[multiple], 1);
 670:	f107 0208 	add.w	r2, r7, #8
 674:	697b      	ldr	r3, [r7, #20]
 676:	4413      	add	r3, r2
 678:	781b      	ldrb	r3, [r3, #0]
 67a:	43db      	mvns	r3, r3
 67c:	b2db      	uxtb	r3, r3
 67e:	2101      	movs	r1, #1
 680:	4618      	mov	r0, r3
 682:	f7ff ff19 	bl	4b8 <shiftOut>
}
 686:	bf00      	nop
 688:	3718      	adds	r7, #24
 68a:	46bd      	mov	sp, r7
 68c:	bd80      	pop	{r7, pc}
 68e:	bf00      	nop
 690:	00000a58 	.word	0x00000a58
 694:	4001009c 	.word	0x4001009c
 698:	40010094 	.word	0x40010094
 69c:	66666667 	.word	0x66666667

000006a0 <am_reset_isr>:
am_reset_isr(void)
{
    //
    // Set the vector table pointer.
    //
    __asm("    ldr    r0, =0xE000ED08\n"
 6a0:	4811      	ldr	r0, [pc, #68]	; (6e8 <zero_loop+0x12>)
 6a2:	4912      	ldr	r1, [pc, #72]	; (6ec <zero_loop+0x16>)
 6a4:	6001      	str	r1, [r0, #0]
          "    str    r1, [r0]");

    //
    // Set the stack pointer.
    //
    __asm("    ldr    sp, [r1]");
 6a6:	f8d1 d000 	ldr.w	sp, [r1]
#ifndef NOFPU
    //
    // Enable the FPU.
    //
    __asm("ldr  r0, =0xE000ED88\n"
 6aa:	4811      	ldr	r0, [pc, #68]	; (6f0 <zero_loop+0x1a>)
 6ac:	6801      	ldr	r1, [r0, #0]
 6ae:	f441 0170 	orr.w	r1, r1, #15728640	; 0xf00000
 6b2:	6001      	str	r1, [r0, #0]
 6b4:	f3bf 8f4f 	dsb	sy
 6b8:	f3bf 8f6f 	isb	sy
          "isb\n");
#endif
    //
    // Copy the data segment initializers from flash to SRAM.
    //
    __asm("    ldr     r0, =_init_data\n"
 6bc:	480d      	ldr	r0, [pc, #52]	; (6f4 <zero_loop+0x1e>)
 6be:	490e      	ldr	r1, [pc, #56]	; (6f8 <zero_loop+0x22>)
 6c0:	4a0e      	ldr	r2, [pc, #56]	; (6fc <zero_loop+0x26>)

000006c2 <copy_loop>:
 6c2:	f850 3b04 	ldr.w	r3, [r0], #4
 6c6:	f841 3b04 	str.w	r3, [r1], #4
 6ca:	4291      	cmp	r1, r2
 6cc:	dbf9      	blt.n	6c2 <copy_loop>
          "        cmp     r1, r2\n"
          "        blt     copy_loop\n");
    //
    // Zero fill the bss segment.
    //
    __asm("    ldr     r0, =_sbss\n"
 6ce:	480c      	ldr	r0, [pc, #48]	; (700 <zero_loop+0x2a>)
 6d0:	490c      	ldr	r1, [pc, #48]	; (704 <zero_loop+0x2e>)
 6d2:	f04f 0200 	mov.w	r2, #0

000006d6 <zero_loop>:
 6d6:	4288      	cmp	r0, r1
 6d8:	bfb8      	it	lt
 6da:	f840 2b04 	strlt.w	r2, [r0], #4
 6de:	dbfa      	blt.n	6d6 <zero_loop>
          "        blt     zero_loop");

    //
    // Call the application's entry point.
    //
    main();
 6e0:	f7ff fcce 	bl	80 <main>

    //
    // If main returns then execute a break point instruction
    //
    __asm("    bkpt     ");
 6e4:	be00      	bkpt	0x0000
}
 6e6:	bf00      	nop
 6e8:	e000ed08 	.word	0xe000ed08
 6ec:	00000000 	.word	0x00000000
 6f0:	e000ed88 	.word	0xe000ed88
 6f4:	00000a84 	.word	0x00000a84
 6f8:	10001000 	.word	0x10001000
 6fc:	10001004 	.word	0x10001004
 700:	10001004 	.word	0x10001004
 704:	10001008 	.word	0x10001008

00000708 <am_nmi_isr>:
// by a debugger.
//
//*****************************************************************************
void
am_nmi_isr(void)
{
 708:	b480      	push	{r7}
 70a:	af00      	add	r7, sp, #0
    //
    // Go into an infinite loop.
    //
    while(1)
 70c:	e7fe      	b.n	70c <am_nmi_isr+0x4>

0000070e <am_adc_isr>:
// for examination by a debugger.
//
//*****************************************************************************
void
am_default_isr(void)
{
 70e:	b480      	push	{r7}
 710:	af00      	add	r7, sp, #0
    //
    // Go into an infinite loop.
    //
    while(1)
 712:	e7fe      	b.n	712 <am_adc_isr+0x4>

00000714 <am_util_delay_ms>:
//! @returns None
//
//*****************************************************************************
void
am_util_delay_ms(uint32_t ui32MilliSeconds)
{
 714:	b580      	push	{r7, lr}
 716:	b084      	sub	sp, #16
 718:	af00      	add	r7, sp, #0
 71a:	6078      	str	r0, [r7, #4]
#if AM_APOLLO3_CLKGEN
    am_hal_clkgen_status_t sClkgenStatus;
    am_hal_clkgen_status_get(&sClkgenStatus);
    ui32HFRC = sClkgenStatus.ui32SysclkFreq;
#else
    ui32HFRC = am_hal_clkgen_sysclk_get();
 71c:	f000 f8b6 	bl	88c <am_hal_clkgen_sysclk_get>
 720:	60f8      	str	r0, [r7, #12]
#endif
    ui32Loops = ui32MilliSeconds * (ui32HFRC / 3000);
 722:	68fb      	ldr	r3, [r7, #12]
 724:	4a07      	ldr	r2, [pc, #28]	; (744 <am_util_delay_ms+0x30>)
 726:	fba2 2303 	umull	r2, r3, r2, r3
 72a:	099b      	lsrs	r3, r3, #6
 72c:	687a      	ldr	r2, [r7, #4]
 72e:	fb02 f303 	mul.w	r3, r2, r3
 732:	60bb      	str	r3, [r7, #8]

    //
    // Call the BOOTROM cycle delay function
    //
    am_hal_flash_delay(ui32Loops);
 734:	68b8      	ldr	r0, [r7, #8]
 736:	f000 f8bf 	bl	8b8 <am_hal_flash_delay>
}
 73a:	bf00      	nop
 73c:	3710      	adds	r7, #16
 73e:	46bd      	mov	sp, r7
 740:	bd80      	pop	{r7, pc}
 742:	bf00      	nop
 744:	057619f1 	.word	0x057619f1

00000748 <am_fault_isr>:
}
#elif defined(__GNUC_STDC_INLINE__)
uint32_t __attribute__((naked))
am_fault_isr(void)
{
    __asm("    push    {r7,lr}");
 748:	b580      	push	{r7, lr}
    __asm("    mov     r0, sp");
 74a:	4668      	mov	r0, sp
    __asm("    adds    r0, #(2*4)");
 74c:	3008      	adds	r0, #8
    __asm("    bl      am_util_faultisr_collect_data");
 74e:	f000 f809 	bl	764 <am_util_faultisr_collect_data>
    __asm("    pop     {r0,pc}");
 752:	bd01      	pop	{r0, pc}
}
 754:	bf00      	nop
 756:	4618      	mov	r0, r3

00000758 <getStackedReg>:

uint32_t __attribute__((naked))
getStackedReg(uint32_t regnum, uint32_t u32SP)
{
    __asm("    lsls    r0, r0, #2");
 758:	0080      	lsls	r0, r0, #2
    __asm("    adds    r0, r1");
 75a:	1840      	adds	r0, r0, r1
    __asm("    ldr     r0, [r0]");
 75c:	6800      	ldr	r0, [r0, #0]
    __asm("    bx      lr");
 75e:	4770      	bx	lr
}
 760:	bf00      	nop
 762:	4618      	mov	r0, r3

00000764 <am_util_faultisr_collect_data>:
// am_fault_isr() was called.
//
//*****************************************************************************
void
am_util_faultisr_collect_data(uint32_t u32IsrSP)
{
 764:	b580      	push	{r7, lr}
 766:	b096      	sub	sp, #88	; 0x58
 768:	af00      	add	r7, sp, #0
 76a:	6078      	str	r0, [r7, #4]
    volatile am_fault_t sFaultData;
    am_hal_mcuctrl_fault_t sHalFaultData = {0};
 76c:	f107 030c 	add.w	r3, r7, #12
 770:	2200      	movs	r2, #0
 772:	601a      	str	r2, [r3, #0]
 774:	605a      	str	r2, [r3, #4]
 776:	609a      	str	r2, [r3, #8]
 778:	60da      	str	r2, [r3, #12]
 77a:	611a      	str	r2, [r3, #16]
 77c:	615a      	str	r2, [r3, #20]

    uint32_t u32Mask = 0;
 77e:	2300      	movs	r3, #0
 780:	657b      	str	r3, [r7, #84]	; 0x54
    // u32Mask is used for 2 things: 1) in the print loop, 2) as a spot to set
    // a breakpoint at the end of the routine.  If the printing is not used,
    // we'll get a compiler warning; so to avoid that warning, we'll use it
    // in a dummy assignment here.
    //
    sFaultData.u32CFSR = u32Mask;       // Avoid compiler warning
 782:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 784:	64fb      	str	r3, [r7, #76]	; 0x4c
    sFaultData.u32CFSR = AM_REGVAL(AM_REG_SYSCTRL_CFSR_O);
 786:	4b2e      	ldr	r3, [pc, #184]	; (840 <am_util_faultisr_collect_data+0xdc>)
 788:	681b      	ldr	r3, [r3, #0]
 78a:	64fb      	str	r3, [r7, #76]	; 0x4c
    sFaultData.u8MMSR  = (sFaultData.u32CFSR >> 0)  & 0xff;
 78c:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 78e:	b2db      	uxtb	r3, r3
 790:	f887 3050 	strb.w	r3, [r7, #80]	; 0x50
    sFaultData.u8BFSR  = (sFaultData.u32CFSR >> 8)  & 0xff;
 794:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 796:	0a1b      	lsrs	r3, r3, #8
 798:	b2db      	uxtb	r3, r3
 79a:	f887 3051 	strb.w	r3, [r7, #81]	; 0x51
    sFaultData.u16UFSR = (sFaultData.u32CFSR >> 16) & 0xffff;
 79e:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 7a0:	0c1b      	lsrs	r3, r3, #16
 7a2:	b29b      	uxth	r3, r3
 7a4:	f8a7 3052 	strh.w	r3, [r7, #82]	; 0x52

    //
    // The address of the location that caused the fault.  e.g. if accessing an
    // invalid data location caused the fault, that address will appear here.
    //
    sFaultData.u32BFAR = AM_REGVAL(AM_REG_SYSCTRL_BFAR_O);
 7a8:	4b26      	ldr	r3, [pc, #152]	; (844 <am_util_faultisr_collect_data+0xe0>)
 7aa:	681b      	ldr	r3, [r3, #0]
 7ac:	64bb      	str	r3, [r7, #72]	; 0x48

    //
    // The address of the instruction that caused the fault is the stacked PC
    // if BFSR bit1 is set.
    //
    sFaultData.u32FaultAddr = (sFaultData.u8BFSR & 0x02) ? getStackedReg(6, u32IsrSP) : 0xffffffff;
 7ae:	f897 3051 	ldrb.w	r3, [r7, #81]	; 0x51
 7b2:	b2db      	uxtb	r3, r3
 7b4:	f003 0302 	and.w	r3, r3, #2
 7b8:	2b00      	cmp	r3, #0
 7ba:	d005      	beq.n	7c8 <am_util_faultisr_collect_data+0x64>
 7bc:	6879      	ldr	r1, [r7, #4]
 7be:	2006      	movs	r0, #6
 7c0:	f7ff ffca 	bl	758 <getStackedReg>
 7c4:	4603      	mov	r3, r0
 7c6:	e001      	b.n	7cc <am_util_faultisr_collect_data+0x68>
 7c8:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 7cc:	647b      	str	r3, [r7, #68]	; 0x44

    //
    // Get the stacked registers.
    // Note - the address of the instruction that caused the fault is u32PC.
    //
    sFaultData.u32R0  = getStackedReg(0, u32IsrSP);
 7ce:	6879      	ldr	r1, [r7, #4]
 7d0:	2000      	movs	r0, #0
 7d2:	f7ff ffc1 	bl	758 <getStackedReg>
 7d6:	4603      	mov	r3, r0
 7d8:	627b      	str	r3, [r7, #36]	; 0x24
    sFaultData.u32R1  = getStackedReg(1, u32IsrSP);
 7da:	6879      	ldr	r1, [r7, #4]
 7dc:	2001      	movs	r0, #1
 7de:	f7ff ffbb 	bl	758 <getStackedReg>
 7e2:	4603      	mov	r3, r0
 7e4:	62bb      	str	r3, [r7, #40]	; 0x28
    sFaultData.u32R2  = getStackedReg(2, u32IsrSP);
 7e6:	6879      	ldr	r1, [r7, #4]
 7e8:	2002      	movs	r0, #2
 7ea:	f7ff ffb5 	bl	758 <getStackedReg>
 7ee:	4603      	mov	r3, r0
 7f0:	62fb      	str	r3, [r7, #44]	; 0x2c
    sFaultData.u32R3  = getStackedReg(3, u32IsrSP);
 7f2:	6879      	ldr	r1, [r7, #4]
 7f4:	2003      	movs	r0, #3
 7f6:	f7ff ffaf 	bl	758 <getStackedReg>
 7fa:	4603      	mov	r3, r0
 7fc:	633b      	str	r3, [r7, #48]	; 0x30
    sFaultData.u32R12 = getStackedReg(4, u32IsrSP);
 7fe:	6879      	ldr	r1, [r7, #4]
 800:	2004      	movs	r0, #4
 802:	f7ff ffa9 	bl	758 <getStackedReg>
 806:	4603      	mov	r3, r0
 808:	637b      	str	r3, [r7, #52]	; 0x34
    sFaultData.u32LR  = getStackedReg(5, u32IsrSP);
 80a:	6879      	ldr	r1, [r7, #4]
 80c:	2005      	movs	r0, #5
 80e:	f7ff ffa3 	bl	758 <getStackedReg>
 812:	4603      	mov	r3, r0
 814:	63bb      	str	r3, [r7, #56]	; 0x38
    sFaultData.u32PC  = getStackedReg(6, u32IsrSP);
 816:	6879      	ldr	r1, [r7, #4]
 818:	2006      	movs	r0, #6
 81a:	f7ff ff9d 	bl	758 <getStackedReg>
 81e:	4603      	mov	r3, r0
 820:	63fb      	str	r3, [r7, #60]	; 0x3c
    sFaultData.u32PSR = getStackedReg(7, u32IsrSP);
 822:	6879      	ldr	r1, [r7, #4]
 824:	2007      	movs	r0, #7
 826:	f7ff ff97 	bl	758 <getStackedReg>
 82a:	4603      	mov	r3, r0
 82c:	643b      	str	r3, [r7, #64]	; 0x40
    // Use the HAL MCUCTRL functions to read the fault data.
    //
#ifdef AM_APOLLO3_MCUCTRL
    am_hal_mcuctrl_info_get(AM_HAL_MCUCTRL_INFO_FAULT_STATUS, &sHalFaultData);
#else
    am_hal_mcuctrl_fault_status(&sHalFaultData);
 82e:	f107 030c 	add.w	r3, r7, #12
 832:	4618      	mov	r0, r3
 834:	f000 f8b2 	bl	99c <am_hal_mcuctrl_fault_status>
    }


#endif

    u32Mask = 0;
 838:	2300      	movs	r3, #0
 83a:	657b      	str	r3, [r7, #84]	; 0x54
    //
    // Spin in an infinite loop.
    // We need to spin here inside the function so that we have access to
    // local data, i.e. sFaultData.
    //
    while(1)
 83c:	e7fe      	b.n	83c <am_util_faultisr_collect_data+0xd8>
 83e:	bf00      	nop
 840:	e000ed28 	.word	0xe000ed28
 844:	e000ed38 	.word	0xe000ed38

00000848 <am_bsp_low_power_init>:
 848:	b508      	push	{r3, lr}
 84a:	f000 f8d3 	bl	9f4 <am_hal_mcuctrl_bucks_enable>
 84e:	f000 f8fd 	bl	a4c <am_hal_vcomp_disable>
 852:	2001      	movs	r0, #1
 854:	f000 f8e4 	bl	a20 <am_hal_rtc_osc_select>
 858:	2001      	movs	r0, #1
 85a:	f000 f823 	bl	8a4 <am_hal_clkgen_osc_stop>
 85e:	f000 f8ed 	bl	a3c <am_hal_rtc_osc_disable>
 862:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
 866:	f000 b8bd 	b.w	9e4 <am_hal_mcuctrl_bandgap_disable>
 86a:	bf00      	nop

0000086c <am_hal_clkgen_sysclk_select>:
 86c:	4b05      	ldr	r3, [pc, #20]	; (884 <am_hal_clkgen_sysclk_select+0x18>)
 86e:	4906      	ldr	r1, [pc, #24]	; (888 <am_hal_clkgen_sysclk_select+0x1c>)
 870:	b410      	push	{r4}
 872:	2200      	movs	r2, #0
 874:	2447      	movs	r4, #71	; 0x47
 876:	601c      	str	r4, [r3, #0]
 878:	6008      	str	r0, [r1, #0]
 87a:	f85d 4b04 	ldr.w	r4, [sp], #4
 87e:	601a      	str	r2, [r3, #0]
 880:	4770      	bx	lr
 882:	bf00      	nop
 884:	40004014 	.word	0x40004014
 888:	40004018 	.word	0x40004018

0000088c <am_hal_clkgen_sysclk_get>:
 88c:	4b03      	ldr	r3, [pc, #12]	; (89c <am_hal_clkgen_sysclk_get+0x10>)
 88e:	4a04      	ldr	r2, [pc, #16]	; (8a0 <am_hal_clkgen_sysclk_get+0x14>)
 890:	6818      	ldr	r0, [r3, #0]
 892:	f000 0107 	and.w	r1, r0, #7
 896:	f852 0021 	ldr.w	r0, [r2, r1, lsl #2]
 89a:	4770      	bx	lr
 89c:	40004018 	.word	0x40004018
 8a0:	00000a64 	.word	0x00000a64

000008a4 <am_hal_clkgen_osc_stop>:
 8a4:	0783      	lsls	r3, r0, #30
 8a6:	d003      	beq.n	8b0 <am_hal_clkgen_osc_stop+0xc>
 8a8:	4b02      	ldr	r3, [pc, #8]	; (8b4 <am_hal_clkgen_osc_stop+0x10>)
 8aa:	681a      	ldr	r2, [r3, #0]
 8ac:	4310      	orrs	r0, r2
 8ae:	6018      	str	r0, [r3, #0]
 8b0:	4770      	bx	lr
 8b2:	bf00      	nop
 8b4:	4000400c 	.word	0x4000400c

000008b8 <am_hal_flash_delay>:
 8b8:	3801      	subs	r0, #1
 8ba:	f47f affd 	bne.w	8b8 <am_hal_flash_delay>
 8be:	4770      	bx	lr

000008c0 <am_hal_gpio_int_enable>:
 8c0:	b410      	push	{r4}
 8c2:	4c05      	ldr	r4, [pc, #20]	; (8d8 <am_hal_gpio_int_enable+0x18>)
 8c4:	4a05      	ldr	r2, [pc, #20]	; (8dc <am_hal_gpio_int_enable+0x1c>)
 8c6:	6823      	ldr	r3, [r4, #0]
 8c8:	4319      	orrs	r1, r3
 8ca:	6021      	str	r1, [r4, #0]
 8cc:	6811      	ldr	r1, [r2, #0]
 8ce:	f85d 4b04 	ldr.w	r4, [sp], #4
 8d2:	4308      	orrs	r0, r1
 8d4:	6010      	str	r0, [r2, #0]
 8d6:	4770      	bx	lr
 8d8:	40010210 	.word	0x40010210
 8dc:	40010200 	.word	0x40010200

000008e0 <am_hal_gpio_int_clear>:
 8e0:	4a02      	ldr	r2, [pc, #8]	; (8ec <am_hal_gpio_int_clear+0xc>)
 8e2:	4b03      	ldr	r3, [pc, #12]	; (8f0 <am_hal_gpio_int_clear+0x10>)
 8e4:	6011      	str	r1, [r2, #0]
 8e6:	6018      	str	r0, [r3, #0]
 8e8:	4770      	bx	lr
 8ea:	bf00      	nop
 8ec:	40010218 	.word	0x40010218
 8f0:	40010208 	.word	0x40010208

000008f4 <am_hal_interrupt_enable>:
 8f4:	280f      	cmp	r0, #15
 8f6:	d80b      	bhi.n	910 <am_hal_interrupt_enable+0x1c>
 8f8:	2805      	cmp	r0, #5
 8fa:	d013      	beq.n	924 <am_hal_interrupt_enable+0x30>
 8fc:	2806      	cmp	r0, #6
 8fe:	d017      	beq.n	930 <am_hal_interrupt_enable+0x3c>
 900:	2804      	cmp	r0, #4
 902:	d104      	bne.n	90e <am_hal_interrupt_enable+0x1a>
 904:	4a0d      	ldr	r2, [pc, #52]	; (93c <am_hal_interrupt_enable+0x48>)
 906:	6813      	ldr	r3, [r2, #0]
 908:	f443 3080 	orr.w	r0, r3, #65536	; 0x10000
 90c:	6010      	str	r0, [r2, #0]
 90e:	4770      	bx	lr
 910:	f1a0 0310 	sub.w	r3, r0, #16
 914:	f003 0c1f 	and.w	ip, r3, #31
 918:	2001      	movs	r0, #1
 91a:	4909      	ldr	r1, [pc, #36]	; (940 <am_hal_interrupt_enable+0x4c>)
 91c:	fa00 f20c 	lsl.w	r2, r0, ip
 920:	600a      	str	r2, [r1, #0]
 922:	4770      	bx	lr
 924:	4805      	ldr	r0, [pc, #20]	; (93c <am_hal_interrupt_enable+0x48>)
 926:	6801      	ldr	r1, [r0, #0]
 928:	f441 3200 	orr.w	r2, r1, #131072	; 0x20000
 92c:	6002      	str	r2, [r0, #0]
 92e:	4770      	bx	lr
 930:	4902      	ldr	r1, [pc, #8]	; (93c <am_hal_interrupt_enable+0x48>)
 932:	680a      	ldr	r2, [r1, #0]
 934:	f442 2380 	orr.w	r3, r2, #262144	; 0x40000
 938:	600b      	str	r3, [r1, #0]
 93a:	4770      	bx	lr
 93c:	e000ed24 	.word	0xe000ed24
 940:	e000e100 	.word	0xe000e100

00000944 <am_hal_itm_enable>:
 944:	4b0d      	ldr	r3, [pc, #52]	; (97c <am_hal_itm_enable+0x38>)
 946:	6818      	ldr	r0, [r3, #0]
 948:	07c2      	lsls	r2, r0, #31
 94a:	d416      	bmi.n	97a <am_hal_itm_enable+0x36>
 94c:	4a0c      	ldr	r2, [pc, #48]	; (980 <am_hal_itm_enable+0x3c>)
 94e:	6811      	ldr	r1, [r2, #0]
 950:	b430      	push	{r4, r5}
 952:	f041 7480 	orr.w	r4, r1, #16777216	; 0x1000000
 956:	6014      	str	r4, [r2, #0]
 958:	6815      	ldr	r5, [r2, #0]
 95a:	01eb      	lsls	r3, r5, #7
 95c:	d5fc      	bpl.n	958 <am_hal_itm_enable+0x14>
 95e:	4809      	ldr	r0, [pc, #36]	; (984 <am_hal_itm_enable+0x40>)
 960:	4c09      	ldr	r4, [pc, #36]	; (988 <am_hal_itm_enable+0x44>)
 962:	4d0a      	ldr	r5, [pc, #40]	; (98c <am_hal_itm_enable+0x48>)
 964:	6005      	str	r5, [r0, #0]
 966:	250f      	movs	r5, #15
 968:	6025      	str	r5, [r4, #0]
 96a:	bc30      	pop	{r4, r5}
 96c:	4908      	ldr	r1, [pc, #32]	; (990 <am_hal_itm_enable+0x4c>)
 96e:	4b09      	ldr	r3, [pc, #36]	; (994 <am_hal_itm_enable+0x50>)
 970:	4a09      	ldr	r2, [pc, #36]	; (998 <am_hal_itm_enable+0x54>)
 972:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 976:	6008      	str	r0, [r1, #0]
 978:	601a      	str	r2, [r3, #0]
 97a:	4770      	bx	lr
 97c:	10001004 	.word	0x10001004
 980:	e000edfc 	.word	0xe000edfc
 984:	e0000fb0 	.word	0xe0000fb0
 988:	e0000e40 	.word	0xe0000e40
 98c:	c5acce55 	.word	0xc5acce55
 990:	e0000e00 	.word	0xe0000e00
 994:	e0000e80 	.word	0xe0000e80
 998:	00150511 	.word	0x00150511

0000099c <am_hal_mcuctrl_fault_status>:
 99c:	490d      	ldr	r1, [pc, #52]	; (9d4 <am_hal_mcuctrl_fault_status+0x38>)
 99e:	4b0e      	ldr	r3, [pc, #56]	; (9d8 <am_hal_mcuctrl_fault_status+0x3c>)
 9a0:	4a0e      	ldr	r2, [pc, #56]	; (9dc <am_hal_mcuctrl_fault_status+0x40>)
 9a2:	681b      	ldr	r3, [r3, #0]
 9a4:	b470      	push	{r4, r5, r6}
 9a6:	680d      	ldr	r5, [r1, #0]
 9a8:	60c5      	str	r5, [r0, #12]
 9aa:	6815      	ldr	r5, [r2, #0]
 9ac:	6841      	ldr	r1, [r0, #4]
 9ae:	4c0c      	ldr	r4, [pc, #48]	; (9e0 <am_hal_mcuctrl_fault_status+0x44>)
 9b0:	6942      	ldr	r2, [r0, #20]
 9b2:	4329      	orrs	r1, r5
 9b4:	6041      	str	r1, [r0, #4]
 9b6:	6824      	ldr	r4, [r4, #0]
 9b8:	f003 0601 	and.w	r6, r3, #1
 9bc:	4322      	orrs	r2, r4
 9be:	7006      	strb	r6, [r0, #0]
 9c0:	f3c3 0640 	ubfx	r6, r3, #1, #1
 9c4:	f3c3 0380 	ubfx	r3, r3, #2, #1
 9c8:	7206      	strb	r6, [r0, #8]
 9ca:	7403      	strb	r3, [r0, #16]
 9cc:	6142      	str	r2, [r0, #20]
 9ce:	bc70      	pop	{r4, r5, r6}
 9d0:	4770      	bx	lr
 9d2:	bf00      	nop
 9d4:	400201c4 	.word	0x400201c4
 9d8:	400201cc 	.word	0x400201cc
 9dc:	400201c0 	.word	0x400201c0
 9e0:	400201c8 	.word	0x400201c8

000009e4 <am_hal_mcuctrl_bandgap_disable>:
 9e4:	4b02      	ldr	r3, [pc, #8]	; (9f0 <am_hal_mcuctrl_bandgap_disable+0xc>)
 9e6:	f06f 0201 	mvn.w	r2, #1
 9ea:	601a      	str	r2, [r3, #0]
 9ec:	4770      	bx	lr
 9ee:	bf00      	nop
 9f0:	400200fc 	.word	0x400200fc

000009f4 <am_hal_mcuctrl_bucks_enable>:
 9f4:	4b08      	ldr	r3, [pc, #32]	; (a18 <am_hal_mcuctrl_bucks_enable+0x24>)
 9f6:	4a09      	ldr	r2, [pc, #36]	; (a1c <am_hal_mcuctrl_bucks_enable+0x28>)
 9f8:	6819      	ldr	r1, [r3, #0]
 9fa:	f041 0002 	orr.w	r0, r1, #2
 9fe:	6018      	str	r0, [r3, #0]
 a00:	6819      	ldr	r1, [r3, #0]
 a02:	f041 0001 	orr.w	r0, r1, #1
 a06:	6018      	str	r0, [r3, #0]
 a08:	6813      	ldr	r3, [r2, #0]
 a0a:	0799      	lsls	r1, r3, #30
 a0c:	d5fc      	bpl.n	a08 <am_hal_mcuctrl_bucks_enable+0x14>
 a0e:	4a03      	ldr	r2, [pc, #12]	; (a1c <am_hal_mcuctrl_bucks_enable+0x28>)
 a10:	6811      	ldr	r1, [r2, #0]
 a12:	07cb      	lsls	r3, r1, #31
 a14:	d5fc      	bpl.n	a10 <am_hal_mcuctrl_bucks_enable+0x1c>
 a16:	4770      	bx	lr
 a18:	40020010 	.word	0x40020010
 a1c:	40020014 	.word	0x40020014

00000a20 <am_hal_rtc_osc_select>:
 a20:	4a05      	ldr	r2, [pc, #20]	; (a38 <am_hal_rtc_osc_select+0x18>)
 a22:	6813      	ldr	r3, [r2, #0]
 a24:	b918      	cbnz	r0, a2e <am_hal_rtc_osc_select+0xe>
 a26:	f023 0080 	bic.w	r0, r3, #128	; 0x80
 a2a:	6010      	str	r0, [r2, #0]
 a2c:	4770      	bx	lr
 a2e:	f043 0180 	orr.w	r1, r3, #128	; 0x80
 a32:	6011      	str	r1, [r2, #0]
 a34:	4770      	bx	lr
 a36:	bf00      	nop
 a38:	4000400c 	.word	0x4000400c

00000a3c <am_hal_rtc_osc_disable>:
 a3c:	4a02      	ldr	r2, [pc, #8]	; (a48 <am_hal_rtc_osc_disable+0xc>)
 a3e:	6813      	ldr	r3, [r2, #0]
 a40:	f043 0010 	orr.w	r0, r3, #16
 a44:	6010      	str	r0, [r2, #0]
 a46:	4770      	bx	lr
 a48:	40004050 	.word	0x40004050

00000a4c <am_hal_vcomp_disable>:
 a4c:	4b01      	ldr	r3, [pc, #4]	; (a54 <am_hal_vcomp_disable+0x8>)
 a4e:	2237      	movs	r2, #55	; 0x37
 a50:	601a      	str	r2, [r3, #0]
 a52:	4770      	bx	lr
 a54:	4000c008 	.word	0x4000c008
 a58:	3b6b1177 	.word	0x3b6b1177
 a5c:	137e3e1d 	.word	0x137e3e1d
 a60:	00003f7f 	.word	0x00003f7f

00000a64 <CSWTCH.4>:
 a64:	016e3600 00b71b00 007a1200 005b8d80     .6n.......z...[.
 a74:	00493e00 003d0900 003450db 002dc6c0     .>I...=..P4...-.
